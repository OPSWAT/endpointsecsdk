///////////////////////////////////////////////////////////////////////////////////////////////
///  Windows OS Vulnerability Scanner
///  Scans only Microsoft/Windows components for vulnerabilities and patches
///  Uses wiv-lite.dat (Windows vulnerabilities) and wuo.dat (Windows patches)
///  
///  This scanner focuses exclusively on Windows OS components, filtering out
///  all third-party applications that would normally be handled by the 
///  regular Vulnerability project using v2mod.dat and uo.dat databases.
///  
///  Created by Chris Seiler
///  OPSWAT OEM Solutions Architect
///////////////////////////////////////////////////////////////////////////////////////////////

using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace VulnerabilityWOS
{
    internal class Program
    {
        /// <summary>
        /// Validates OESIS API return codes to ensure successful execution
        /// </summary>
        /// <param name="rc">Return code from OESIS API call</param>
        /// <exception cref="Exception">Thrown when return code indicates failure (< 0)</exception>
        private static void CheckSuccess(int rc)
        {
            // OESIS Return code reference: https://software.opswat.com/OESIS_V4/html/c_return_codes.html
            // Positive values (>= 0) indicate SUCCESS
            // Negative values (< 0) indicate FAILURE
            if (rc < 0)
            {
                Console.Out.WriteLine("Failed to execute OESIS API call with return code: " + rc);
                throw new Exception();
            }
        }


        /// <summary>
        /// Core OESIS API invocation method - sends JSON commands to the OESIS framework
        /// and retrieves JSON responses. This is the primary communication interface.
        /// </summary>
        /// <param name="json_config">JSON string containing the API method and parameters</param>
        /// <param name="json_out">Output parameter containing the JSON response from OESIS</param>
        /// <returns>Return code indicating success (>= 0) or failure (< 0)</returns>
        private static int Invoke(string json_config, out string json_out)
        {
            IntPtr outPtr = IntPtr.Zero;
            // Call the native OESIS API with our JSON input
            int rc = OESISAdapter.wa_api_invoke(json_config, out outPtr);
            json_out = "{ }"; // Default empty JSON response
            
            // If OESIS returned data, convert the native pointer to a managed string
            if (outPtr != IntPtr.Zero)
            {
                json_out = XStringMarshaler.PtrToString(outPtr);
                // Always free the native memory to prevent memory leaks
                OESISAdapter.wa_api_free(outPtr);
            }
            return rc;
        }

        /// <summary>
        /// Initializes the OESIS Framework with license validation and configuration.
        /// This must be called before any other OESIS operations can be performed.
        /// </summary>
        /// <exception cref="Exception">Thrown if license file is missing or initialization fails</exception>
        private static void InitializeFramework()
        {
            // Get the directory where the executable is running
            string currentPath = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
            string passKeyPath = Path.Combine(currentPath, "pass_key.txt");

            // Verify that the OPSWAT license file exists
            if (!File.Exists(passKeyPath))
            {
                Console.WriteLine("Could not find a pass_key.txt file. Make sure that the license provided during evaluation is in the executable directory.");
                throw new Exception("License pass_key.txt file not found");
            }

            // Read the license key from the file
            string passkey = File.ReadAllText(passKeyPath);
            
            // Configure OESIS framework settings
            // - passkey_string: The OPSWAT license key
            // - enable_pretty_print: Makes JSON output more readable
            // - online_mode: Enables online features (set to true for full functionality)
            // - silent_mode: Reduces verbose logging output
            string config = "{ \"config\" : { \"passkey_string\": \"" + passkey + "\", \"enable_pretty_print\": true, \"online_mode\": true, \"silent_mode\": true } }";

            // Initialize the OESIS framework with our configuration
            IntPtr outPtr = IntPtr.Zero;
            // NOTE: If you get a "Bad Image" exception, check that "Prefer 32-bit" is unchecked in project properties
            int rc = OESISAdapter.wa_api_setup(config, out outPtr);
            string json_out = "{ }";
            
            // Process the initialization response
            if (outPtr != IntPtr.Zero)
            {
                json_out = XStringMarshaler.PtrToString(outPtr);
                OESISAdapter.wa_api_free(outPtr);
            }
            else
            {
                Console.Out.WriteLine("Failed to initialize OESIS framework with return code: " + rc);
                // Return code reference: https://software.opswat.com/OESIS_V4/html/c_return_codes.html
                throw new Exception("Failed to initialize OESIS framework");
            }
        }



        /// <summary>
        /// Parses the JSON response from DetectProducts() and converts it into a list of Product objects.
        /// Each product contains a signature ID, name, and vendor information.
        /// </summary>
        /// <param name="detect_product_json">JSON response from OESIS DetectProducts API call</param>
        /// <returns>List of Product objects with signature IDs, names, and vendor information</returns>
        public static List<Product> GetProductList(string detect_product_json)
        {
            List<Product> result = new List<Product>();

            // Parse the JSON response from OESIS
            dynamic jsonOut = JObject.Parse(detect_product_json);
            var products = jsonOut.result.detected_products;

            // Extract each detected product's information
            for (int i = 0; i < products.Count; i++)
            {
                Product newProduct = new Product();
                newProduct.signatureId = products[i].signature;        // Unique OESIS product identifier
                newProduct.name = (string)products[i].product.name;    // Product display name
                newProduct.vendor = (string)products[i].vendor.name;   // Vendor/manufacturer name
                result.Add(newProduct);
            }

            return result;
        }

        /// <summary>
        /// Queries the loaded vulnerability database (wiv-lite.dat) for CVE information about a specific product.
        /// This method uses the Windows OS vulnerability data to find security issues.
        /// 
        /// OESIS Method 50505: Get Product Vulnerabilities
        /// </summary>
        /// <param name="signatureId">OESIS signature ID of the product to query</param>
        /// <returns>JSON response containing CVE list, descriptions, and severity information</returns>
        /// <exception cref="Exception">Thrown if the query fails (e.g., -1019 for no data available)</exception>
        public static string GetProductVulnerability(int signatureId)
        {
            string result = "";
            // Build JSON request to query vulnerability database for this product
            string json_in = "{\"input\": { \"method\": 50505, \"signature\": " + signatureId + " } }";
            int rc = Invoke(json_in, out result);
            
            if (rc < 0)
            {
                // Common error codes:
                // -1019: WA_VMOD_ERROR_OFFLINEVMOD_NOT_INITIALIZED - Product not in wiv-lite.dat
                throw new Exception("GetProductVulnerability failed to run correctly. Return code: " + rc + " Response: " + result);
            }

            return result;
        }

        /// <summary>
        /// Loads the Windows OS vulnerability database (wiv-lite.dat) into memory for querying.
        /// This database contains CVE information specifically for Windows OS components and system files.
        /// Must be called before using GetProductVulnerability() for Windows products.
        /// 
        /// OESIS Method 50520: Consume Offline VMOD Database
        /// Following VAPM-Scanner pattern for Windows OS vulnerability data
        /// </summary>
        /// <param name="databaseFile">Path to the wiv-lite.dat file (Windows vulnerability database)</param>
        /// <exception cref="Exception">Thrown if database loading fails</exception>
        public static void ConsumeOfflineVmodDatabase(string databaseFile)
        {
            // Build JSON request to load the vulnerability database
            string json_in = "{\"input\" : {\"method\" : 50520, \"dat_input_source_file\" : \"" + databaseFile + "\"}}";
            string result;

            int rc = Invoke(json_in, out result);
            if (rc < 0)
            {
                throw new Exception("ConsumeOfflineVmodDatabase failed to load " + databaseFile + ". Return code: " + rc + " Response: " + result);
            }
        }

        /// <summary>
        /// Loads the Windows OS patch database (wuo.dat) into memory for patch level queries.
        /// This database contains information about Windows updates, patches, and their relationships
        /// to vulnerabilities. Works in conjunction with wiv-lite.dat to provide complete patch status.
        /// 
        /// OESIS Method 50302: Load Patch Database  
        /// Following VAPM-Scanner pattern for Windows OS patch data
        /// </summary>
        /// <param name="databaseFile">Path to the wuo.dat file (Windows OS patch database)</param>
        /// <param name="checksumFile">Optional checksum file for integrity validation (can be empty)</param>
        /// <exception cref="Exception">Thrown if database loading fails</exception>
        public static void LoadPatchDatabase(string databaseFile, string checksumFile)
        {
            string result;
            // Build JSON request to load the patch database
            string json_in = "{\"input\" : {\"method\" : 50302, \"dat_input_source_file\" : \"" + databaseFile + "\"}}";

            // If a checksum file is provided, include it for integrity verification
            if (!string.IsNullOrEmpty(checksumFile))
            {
                json_in = "{\"input\" : {\"method\" : 50302, \"dat_input_source_file\" : \"" + databaseFile + "\", \"dat_input_checksum_file\" : \"" + checksumFile + "\"}}";
            }

            int rc = Invoke(json_in, out result);
            if (rc < 0)
            {
                throw new Exception("LoadPatchDatabase failed to load " + databaseFile + ". Return code: " + rc + " Response: " + result);
            }
        }

        /// <summary>
        /// Attempts to retrieve patch/update information for Windows OS components.
        /// This method tries multiple OESIS API methods to find patch data since different
        /// products may respond to different query types. Currently experimental.
        /// 
        /// NOTE: This method is not currently used in the main scanning workflow
        /// but could be enabled for enhanced patch reporting functionality.
        /// </summary>
        /// <param name="signatureId">OESIS signature ID of the product to query for patches</param>
        /// <returns>JSON response containing patch information, or empty result if no patches found</returns>
        public static string GetWindowsOSPatches(int signatureId)
        {
            // Try different OESIS method numbers that might return patch information
            // These are experimental - patch querying may require different approaches
            int[] patchQueryMethods = { 50505, 50510, 50515, 50525, 50530 };
            
            foreach (int method in patchQueryMethods)
            {
                try
                {
                    string result = "";
                    string json_in = "{\"input\": { \"method\": " + method + ", \"signature\": " + signatureId + ", \"query_type\": \"patches\" } }";
                    int rc = Invoke(json_in, out result);
                    if (rc >= 0)
                    {
                        dynamic jsonOut = JObject.Parse(result);
                        // Check if the response contains patch-related data
                        if (jsonOut.result != null && (jsonOut.result.patches != null || jsonOut.result.updates != null))
                        {
                            return result;
                        }
                    }
                }
                catch (Exception)
                {
                    // Continue trying the next method if this one fails
                }
            }
            
            // Return empty patch data if no methods succeeded
            return "{\"result\": {\"has_patches\": false, \"patches\": []}}";
        }

        /// <summary>
        /// Formats vulnerability data into JSON structure for output file.
        /// Creates a JSON object containing product information and its associated CVE data.
        /// </summary>
        /// <param name="product">Product object containing name and signature ID</param>
        /// <param name="vulnData">Raw JSON vulnerability data from OESIS API</param>
        /// <returns>Formatted JSON string combining product info with vulnerability data</returns>
        private static string GetCVEProductJSON(Product product, string vulnData)
        {
            StringBuilder resultString = new StringBuilder();
            // Build JSON structure: { "product": { "name": "...", "signatureId": ..., "data": {...} } }
            resultString.Append("{");
            resultString.Append("\"product\":");
            resultString.Append("{");

            resultString.Append("\"name\":\"" + product.name + "\",");
            resultString.Append("\"signatureId\":" + product.signatureId + ",");
            resultString.Append("\"data\":" + vulnData );  // Raw vulnerability JSON from OESIS
            resultString.Append("}");
            resultString.Append("}");
            return resultString.ToString();
        }

        /// <summary>
        /// Formats vulnerability and patch data into JSON structure for enhanced output.
        /// Creates a JSON object containing product information, CVE data, and patch information.
        /// Currently unused but available for future patch reporting features.
        /// </summary>
        /// <param name="product">Product object containing name and signature ID</param>
        /// <param name="vulnData">Raw JSON vulnerability data from OESIS API</param>
        /// <param name="patchData">Raw JSON patch data from OESIS API</param>
        /// <returns>Formatted JSON string combining product info with vulnerability and patch data</returns>
        private static string GetCVEProductJSONWithPatches(Product product, string vulnData, string patchData)
        {
            StringBuilder resultString = new StringBuilder();
            // Build JSON structure with both vulnerability and patch data
            resultString.Append("{");
            resultString.Append("\"product\":");
            resultString.Append("{");

            resultString.Append("\"name\":\"" + product.name + "\",");
            resultString.Append("\"signatureId\":" + product.signatureId + ",");
            resultString.Append("\"vulnerabilityData\":" + vulnData + ",");    // CVE information
            resultString.Append("\"patchData\":" + patchData );                // Patch/update information
            resultString.Append("}");
            resultString.Append("}");
            return resultString.ToString();
        }

        /// <summary>
        /// Appends vulnerability data for a product to the results JSON array being built.
        /// Handles comma separation between JSON array elements.
        /// </summary>
        /// <param name="resultString">StringBuilder containing the JSON array being constructed</param>
        /// <param name="product">Product with vulnerability data</param>
        /// <param name="vulnData">Raw vulnerability JSON from OESIS</param>
        /// <param name="isFirst">True if this is the first item in the array (no leading comma needed)</param>
        private static void PrintDataToResultsFile(StringBuilder resultString, Product product, string vulnData, bool isFirst)
        {
            // Format the product and vulnerability data as JSON
            string productCVEJson = GetCVEProductJSON(product, vulnData);
            
            // Add comma separator for JSON array (except for first element)
            if (!isFirst)
            {
                resultString.Append(",");
            }

            // Append this product's data to the results JSON array
            resultString.Append(productCVEJson);
        }

        /// <summary>
        /// Appends vulnerability and patch data for a product to the results JSON array.
        /// Enhanced version that includes patch information. Currently unused.
        /// </summary>
        /// <param name="resultString">StringBuilder containing the JSON array being constructed</param>
        /// <param name="product">Product with vulnerability and patch data</param>
        /// <param name="vulnData">Raw vulnerability JSON from OESIS</param>
        /// <param name="patchData">Raw patch JSON from OESIS</param>
        /// <param name="isFirst">True if this is the first item in the array (no leading comma needed)</param>
        private static void PrintDataToResultsFileWithPatches(StringBuilder resultString, Product product, string vulnData, string patchData, bool isFirst)
        {
            // Format the product, vulnerability, and patch data as JSON
            string productCVEJson = GetCVEProductJSONWithPatches(product, vulnData, patchData);
            
            // Add comma separator for JSON array (except for first element)
            if (!isFirst)
            {
                resultString.Append(",");
            }

            // Append this product's enhanced data to the results JSON array
            resultString.Append(productCVEJson);
        }

        /// <summary>
        /// Filters detected products to include only Windows OS and Microsoft components.
        /// This ensures the Windows OS scanner focuses exclusively on Microsoft products
        /// and excludes all third-party applications (Chrome, Adobe, etc.).
        /// </summary>
        /// <param name="product">Product to evaluate for inclusion</param>
        /// <returns>True if product should be included in Windows OS scanning, false otherwise</returns>
        private static bool IsWindowsOSComponent(Product product)
        {
            string vendorName = product.vendor.ToLower();
            
            // Only include products where Microsoft is the vendor
            // This captures Windows OS components, Office, .NET, Visual C++, etc.
            // while excluding third-party software like Chrome, Adobe, Zoom, etc.
            return vendorName.Contains("microsoft");
        }

        /// <summary>
        /// Main entry point for the Windows OS Vulnerability Scanner.
        /// 
        /// CURRENT WORKFLOW:
        /// 1. Initialize OESIS framework with licensing
        /// 2. Load Windows OS databases (wuo.dat for patches, wiv-lite.dat for vulnerabilities) 
        /// 3. Test vulnerability query for signature ID 1103
        /// 4. Display results to console and save JSON report
        /// 5. Clean up OESIS framework resources
        /// 
        /// NOTE: This is currently a minimal test implementation that queries a single
        /// signature ID (1103) rather than scanning all installed products.
        /// </summary>
        /// <param name="args">Command line arguments (currently unused)</param>
        static void Main(string[] args)
        {
            string products_json = "";
            try
            {
                // Initialize JSON array for collecting vulnerable products
                StringBuilder resultString = new StringBuilder();
                resultString.Append("[");

                // STEP 1: Initialize the OESIS framework with license validation
                InitializeFramework();
                
                // STEP 2: Load Windows OS databases (patch first, then vulnerability)
                Console.WriteLine("Loading Windows OS patch database (wuo.dat)...");
                LoadPatchDatabase("wuo.dat", "");  // Windows OS patches database
                Console.WriteLine("Successfully loaded wuo.dat");
                
                Console.WriteLine("Loading Windows OS vulnerability database (wiv-lite.dat)...");
                ConsumeOfflineVmodDatabase("wiv-lite.dat");  // Windows OS vulnerabilities database
                Console.WriteLine("Successfully loaded wiv-lite.dat");

                // STEP 3: Test vulnerability query for signature ID 1103
                Console.WriteLine("Testing vulnerability query for Windows OS component...");
                string vulnData = GetProductVulnerability(1103);
                Console.WriteLine(vulnData);

                // STEP 4: Clean up OESIS framework resources
                OESISAdapter.wa_api_teardown();

                // STEP 5: Save detailed results to JSON file
                resultString.Append("]");  // Close JSON array

                string resultsFile = Path.Combine(Directory.GetCurrentDirectory(), "windowsOSVulnerabilityResult.json");
                File.Delete(resultsFile);  // Remove any existing results file
                File.WriteAllText(resultsFile, resultString.ToString());
                Console.WriteLine("More detail can be found in result file: " + resultsFile);
            }
            catch (Exception e)
            {
                // Global error handler for unexpected failures
                Console.Out.WriteLine("Received an Exception: " + e);
                Console.Out.WriteLine("JSON_RESULT: " + products_json);
            }
        }
    }
}
